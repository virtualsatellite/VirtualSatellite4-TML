/*******************************************************************************
 * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *******************************************************************************/
package de.dlr.sc.virsat.model.ext.tml.generator.templates.tasking.source.cpp

import de.dlr.sc.virsat.model.ext.tml.behavioral.behavioral.BehavioralParameterDefinition
import de.dlr.sc.virsat.model.ext.tml.behavioral.behavioral.EnumStorageType
import de.dlr.sc.virsat.model.ext.tml.behavioral.behavioral.EnumValueType
import de.dlr.sc.virsat.model.ext.tml.generator.IGenerationConfigurationProvider
import de.dlr.sc.virsat.model.ext.tml.generator.impl.GenerationConfigurationProvider
import de.dlr.sc.virsat.model.ext.tml.behavioral.behavioral.ChannelBehaviorDefinition

/**
 * @author nepa_ay
 *
 */
class CppChannelBehaviorTemplate extends AbstractTaskingTemplate {
	
	protected IGenerationConfigurationProvider gcp = GenerationConfigurationProvider.instance;
	protected ChannelBehaviorDefinition channelBehaviorDefinition;
	
	new (ChannelBehaviorDefinition channelBehaviorDefinition) {
		this.channelBehaviorDefinition = channelBehaviorDefinition;
	}
	
	private def printCallToUnImplementedMethod(String className, String returnType, String methodName, String params)'''
		std::cerr << "Call to unimplemented method. «channelTemplateHead» «returnType» «className»::«methodName»(«params»)" << std::endl;
	'''
	
	private def printAutoGeneratedMethodStub(String className, String returnType, String methodName, String params)'''
		std::cerr << "Auto-generated method stub.«channelTemplateHead» «returnType» «className»::«methodName»(«params»)" << std::endl;
		///TODO: Write your code for «className» here...
	'''
	
	private def getChannelTemplateHead(){
		var ret = "";
		if(channelHasSize(channelBehaviorDefinition)){
			ret += "template <typename T, unsigned int SIZE>"
		} else {
			ret += "template <typename T>"
		}
		return ret
	}
	
	private def getChannelTemplateClassName(String channelName){
		var ret = "";
		if(channelHasSize(channelBehaviorDefinition)){
			ret += channelName + "<T, SIZE>"
		} else {
			ret += channelName + "<T>"
		}
		return ret
	}
	
	
	private def printParameter(BehavioralParameterDefinition behavioralParameterDefinition, boolean printType, boolean init, String name_prefix){
		if (behavioralParameterDefinition.valueType === EnumValueType.INTEGER){
			return '''«IF printType»int «ENDIF»«name_prefix»«behavioralParameterDefinition.name»«IF init» = «getChannelParameterValue(behavioralParameterDefinition)»«ENDIF»'''
		} 
		else if (behavioralParameterDefinition.valueType === EnumValueType.FLOAT) {
			return '''«IF printType»float «ENDIF»«name_prefix»«behavioralParameterDefinition.name»«IF init» = «getChannelParameterValue(behavioralParameterDefinition)»«ENDIF»'''
		}
		else if (behavioralParameterDefinition.valueType === EnumValueType.STRING){
			return '''«IF printType»const char * «ENDIF»«name_prefix»«behavioralParameterDefinition.name»«IF init» = «getChannelParameterValue(behavioralParameterDefinition)»«ENDIF»'''
		}
	}
	
	private def printConstructorParameters(boolean printType){
		'''«FOR param : channelBehaviorDefinition.parameters SEPARATOR ", "»«printParameter(param, printType, false, "arg_")»«ENDFOR»'''
	}
	
	private def provideVirtualImpl(){
		//TODO: currently only FIFO implementation is available
		if (channelBehaviorDefinition.storageType === EnumStorageType.FIFO){
			return true;
		} else {
			return false;
		}
	}
	
	private def declareChannelMethods(boolean hasVirtualImpl, String channelName)'''
		«getChannelTemplateHead»
		T* «channelName.getChannelTemplateClassName»::allocate(void) {
			«IF hasVirtualImpl»
				«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
					«printCallToUnImplementedMethod(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
					return NULL;
				«ELSE»
					//Implement memory allocation for «channelBehaviorDefinition.storageType» in concrete class...
					return NULL;
				«ENDIF»
			«ELSE»
				«printAutoGeneratedMethodStub(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
				return NULL;
			«ENDIF»
		}
		
		«getChannelTemplateHead»
		bool «channelName.getChannelTemplateClassName»::push(T* data) {
			«IF hasVirtualImpl»
				«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
					bool result = m_data.enqueue(data);
					«channelName.getChannelTemplateClassName»::«gcp.getAbstractChannelClassName()»::TaskChannel::push();
					return result;
				«ELSE»
					//Implement push method for «channelBehaviorDefinition.storageType» in concrete class...
					return false;
				«ENDIF»
			«ELSE»
				«printAutoGeneratedMethodStub(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
				return false;
			«ENDIF»
		}
		
		«getChannelTemplateHead»
		bool «channelName.getChannelTemplateClassName»::push(T& data) {
			«IF hasVirtualImpl»
				«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
					«printCallToUnImplementedMethod(channelName.getChannelTemplateClassName, 'bool', 'push', 'T& data')»
					return false;
				«ELSE»
					//Implement pop for «channelBehaviorDefinition.storageType» in concrete class...
					return false;
				«ENDIF»
			«ELSE»
				«printAutoGeneratedMethodStub(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
				return false;
			«ENDIF»
		}
				
		«getChannelTemplateHead»
		T* «channelName.getChannelTemplateClassName»::pop(void) {
			«IF hasVirtualImpl»
				«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
					return m_data.dequeue();
				«ELSE»
					//Implement pop for «channelBehaviorDefinition.storageType» in concrete class...
					return NULL;
				«ENDIF»
			«ELSE»
				«printAutoGeneratedMethodStub(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
				return NULL;
			«ENDIF»
		}
		
		«getChannelTemplateHead»
		bool «channelName.getChannelTemplateClassName»::isEmpty(void) const {
			«IF hasVirtualImpl»
				«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
					return m_data.isEmpty();
				«ELSE»
					//Implement isEmpty for «channelBehaviorDefinition.storageType» in concrete class...
					return true;
				«ENDIF»
			«ELSE»
				«printAutoGeneratedMethodStub(channelName.getChannelTemplateClassName, 'T*', 'allocate', 'void')»
				return true;
			«ENDIF»
		}
	'''
		
	override String compileAbstractHeader() '''
		
		«getGenerationAbstractHeaderDescription("CppChannelBehaviorTemplate.xtend")»
		
		«val className = channelBehaviorDefinition.name.abstractName»
		#ifndef «getConstantsName(className)»_H_
		#define «getConstantsName(className)»_H_
		
		#include <iostream>
		#include "taskChannel.h"
		#include "«gcp.getAbstractChannelClassName()».h"
		«IF channelBehaviorDefinition.storageType === EnumStorageType.FIFO»
			#include "«gcp.getQueueClassName()».h"
		«ENDIF»
		namespace «gcp.projectName» {
		
			«channelTemplateHead»
			class «className»: public «gcp.getAbstractChannelClassName()»<T> {
				
				public:
					«className»(«printConstructorParameters(true)»): «gcp.getAbstractChannelClassName()»<T>()
						«IF provideVirtualImpl»
							, m_data()
						«ENDIF»
						«FOR param : channelBehaviorDefinition.parameters»
							, m_«param.name»(arg_«param.name»)
						«ENDFOR»
						{
						  }
						  «IF !channelBehaviorDefinition.parameters.isNullOrEmpty»				    
						  	«className»(): «gcp.getAbstractChannelClassName()»<T>()
						  		«IF provideVirtualImpl»
						  			, m_data()
						  		«ENDIF»
						  		«FOR param : channelBehaviorDefinition.parameters»
						  			, m_«param.name»(«param.channelParameterValue»)
						  		«ENDFOR»
						  		{
						  	}
						  «ENDIF»
						  
						  virtual ~«className»(){ }
						  
						  «IF channelBehaviorDefinition.storageType === EnumStorageType.CUSTOM»
						  	//Keep methods pure virtual for «channelBehaviorDefinition.storageType» channels... concrete implementations in src/channel folder.
						  «ENDIF»
						  virtual T* allocate(void)«IF !provideVirtualImpl» = 0«ENDIF»;
					virtual bool push(T* data)«IF !provideVirtualImpl» = 0«ENDIF»;
					virtual bool push(T& data)«IF !provideVirtualImpl» = 0«ENDIF»;
					virtual T* pop(void)«IF !provideVirtualImpl» = 0«ENDIF»;
					virtual bool isEmpty(void) const«IF !provideVirtualImpl» = 0«ENDIF»;
					
				protected:
					«FOR param : channelBehaviorDefinition.parameters»
						«printParameter(param, true, false, "m_")»;
					«ENDFOR»
					«IF provideVirtualImpl»
						«gcp.getQueueClassName()»<T, SIZE> m_data;
					«ENDIF»
			};
			«IF provideVirtualImpl»
				«declareChannelMethods(true, channelBehaviorDefinition.name.abstractName)»
			«ENDIF»
		}
		#endif /*  «getConstantsName(className)»_H_ */
	'''
	
	override compileAbstractSource() {
		throw new UnsupportedOperationException("No Abstract Source")
	}
	
	override compileHeader() '''
		«var className = channelBehaviorDefinition.name»
		
		«getGenerationHeaderDescription("CppChannelBehaviorTemplate.xtend")»
		
		#ifndef «getConstantsName(className)»_H_
		#define «getConstantsName(className)»_H_
		
		#include <iostream>
		#include "taskChannel.h"
		#include "«className.abstractName».h"
		
		namespace «gcp.projectName» {
		
			«channelTemplateHead»
			class «className»: public «className.abstractName.channelTemplateClassName»{
				
				public:
				    «className»(«printConstructorParameters(true)»): «className.abstractName.channelTemplateClassName»(«printConstructorParameters(false)») { 
				    }
				    «IF !channelBehaviorDefinition.parameters.isNullOrEmpty»
				    	«className»(): «className.abstractName.channelTemplateClassName»() { 
				    	}
				    «ENDIF»
				    ~«className»(){ }
				    
				    «IF provideVirtualImpl»
				    	/** Uncomment following section and implement methods to override them.*/
				    	/*
				«ENDIF»
				T* allocate(void);
					bool push(T* data);
					bool push(T& data);
					T* pop(void);
					bool isEmpty(void) const;
					   «IF provideVirtualImpl»*/«ENDIF»
					   
				private:
				  		//Define private variables here..
			};
			
			«IF provideVirtualImpl»
				/** Uncomment following section and implement methods to override them.*/
				/*
			«ENDIF»
			«declareChannelMethods(false, className)»
			«IF provideVirtualImpl»*/«ENDIF»
			
		}
		#endif /*  «getConstantsName(className)»_H_ */
	'''
	
	override compileSource() {
		throw new UnsupportedOperationException("No Concrete Source")
	}
	
}
